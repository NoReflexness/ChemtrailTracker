You are Grok 3, built by xAI. I’m working on a Python-based flight tracking app using Flask, SocketIO, and Leaflet.js, hosted in a Docker container (python:3.12-slim). Project Description: Flight Tracker
Purpose:
The "Flight Tracker" is a web-based application designed to monitor and visualize real-time flight data over specified geographic areas using the OpenSky Network API. The project aims to provide users with an interactive dashboard to track flight paths, classify flights (e.g., commercial, survey, agriculture, cloud seeding) using both rule-based heuristics and a machine learning model, and analyze flight statistics such as altitude, velocity, and duration. The application is intended for aviation enthusiasts, researchers, or analysts interested in flight patterns and behaviors.
Key Features:  
Real-Time Monitoring: 
Users can define rectangular geographic areas to monitor via a Leaflet-based map interface.
Polls the OpenSky API at configurable intervals (30s, 1m, 5m) to fetch flight states within these areas.
Flight Visualization: 
Displays flight paths as polylines and current positions as airplane markers on an interactive map.
Includes popups with detailed flight info (ID, classification, altitude, velocity, averages, duration).
Classification: 
Rule-based classification based on altitude, velocity, and turn frequency.
Machine learning classification using a RandomForestClassifier, trainable with manually classified data.
Active Flights List: 
Compact view: Lists flight IDs and classifications.
Detailed view (on selection): Shows altitude, velocity, heading, averages, and duration with icons.
Statistics: 
Computes and displays average altitude, velocity, and flight duration for each tracked flight.
User Interaction: 
Manual classification via dropdowns in the active flights list.
"Retrain Model" button to update the ML model with manual classifications.
Area management (start/stop monitoring, delete areas).
Dark Theme UI: 
A responsive, dark-themed dashboard with a map, controls, flight list, and logs.
Tech Stack:  
Backend: Flask (Python) with Flask-SocketIO for real-time updates, SQLAlchemy (SQLite database), OpenSky API integration.
Frontend: HTML/CSS/JavaScript, Leaflet.js for mapping, Socket.IO for real-time communication.
ML: Scikit-learn (RandomForestClassifier) for flight classification.
Deployment: Dockerized for consistent runtime.
Current State:  
Working Features: 
Real-time flight data fetching and storage in SQLite (/data/flights.db).
Map visualization of flight markers (single points work), with detailed popups.
Rule-based classification functional as a fallback.
Socket events (flight_batch_update) correctly emit updates.
Issues: 
Active Flights List Empty: Despite backend updates (e.g., "Updated 31 flights"), the frontend list isn’t populating due to a TypeError: Cannot read properties of undefined (reading 'length') in utils.js. This stems from flight.line being undefined for flights with multiple points, indicating a bug in renderFlightPath’s polyline creation.
ML Model Training: The RandomForestClassifier isn’t fitted initially, requiring manual classification of 10+ flights with 2+ points and 2+ classes. Retraining fails with a TypeError due to None classifications in the training data, fixed in the latest ml_model.py.
Recent Fixes: 
Corrected points handling to ensure JSON string storage, resolving a TypeError.
Adjusted analyze_flight to use points_list and handle unfitted ML models gracefully.
Next Steps:  
Resolve the active flights list issue by fixing polyline rendering.
Enhance ML training with an initial dataset or auto-training on startup.
Add map interactivity features (e.g., zoom controls, path animations).
Source Code
flight_tracker/__init__.py
python
from flask import Flask
from flask_socketio import SocketIO
from flight_tracker.utils import logger, setup_logging
from flight_tracker.models import db, init_db, FlightPath
from flight_tracker.monitoring import init_indexes

def create_app():
    app = Flask(__name__)
    socketio = SocketIO(app)

    setup_logging(socketio)

    from flight_tracker.routes import register_routes
    from flight_tracker.monitoring import start_monitoring

    init_db(app)
    
    with app.app_context():
        init_indexes()
        # One-time migration for corrupt data
        for flight in FlightPath.query.all():
            try:
                points = json.loads(flight.points) if flight.points else []
                if not isinstance(points, list) or (points and not all(isinstance(p, list) for p in points)):
                    logger.warning(f"Fixing corrupt points for {flight.flight_id}: {flight.points}")
                    flight.points = json.dumps([])  # Reset to empty list
                    db.session.commit()
                flight.update_stats()  # Ensure stats are recalculated
            except json.JSONDecodeError:
                logger.warning(f"Resetting corrupt JSON for {flight.flight_id}")
                flight.points = json.dumps([])
                db.session.commit()

    register_routes(app, socketio)

    @socketio.on('connect')
    def handle_connect():
        logger.info("Client connected")
        start_monitoring(app, socketio)

    return app, socketio
flight_tracker/monitoring.py
python
import requests
import time
import threading
import configparser
import json
from flight_tracker.utils import logger
from flight_tracker.models import db, MonitoredArea, FlightPath
from flight_tracker.analysis import analyze_flight
from sqlalchemy.orm import attributes
from sqlalchemy import text

BASE_URL = "https://opensky-network.org/api/states/all"
config = configparser.ConfigParser()
config.read('/root/.config/pyopensky/settings.conf')
USERNAME = config['opensky']['username']
PASSWORD = config['opensky']['password']

credits_used = 0
MAX_CREDITS = 4000

def calculate_credit_cost(lamin, lamax, lomin, lomax):
    area = (lamax - lamin) * (lomax - lomin)
    if area <= 25:
        return 1
    elif area <= 100:
        return 2
    elif area <= 400:
        return 3
    else:
        return 4

def fetch_flight_data(area):
    global credits_used
    cost = calculate_credit_cost(area.lamin, area.lamax, area.lomin, area.lomax)
    if credits_used + cost > MAX_CREDITS:
        logger.warning("Credit limit reached for today.")
        return None
    
    params = {"lamin": area.lamin, "lamax": area.lamax, "lomin": area.lomin, "lomax": area.lomax}
    try:
        response = requests.get(BASE_URL, params=params, auth=(USERNAME, PASSWORD))
        response.raise_for_status()
        states = response.json()
        credits_used += cost
        logger.info(f"Fetched data for area {area.id}. Credits used: {credits_used}/{MAX_CREDITS}")
        return states
    except requests.RequestException as e:
        logger.error(f"Failed to fetch data: {e}")
        return None

def cleanup_old_flights():
    cutoff = int(time.time()) - (24 * 3600)
    db.session.execute(text("DELETE FROM flight_path WHERE last_updated < :cutoff"), {"cutoff": cutoff})
    db.session.commit()
    logger.info("Cleaned up old flights")

def process_states(states, socketio):
    if not states or 'states' not in states:
        logger.warning("No states data to process")
        return
    
    timestamp = states['time']
    flight_updates = []
    new_flights = []
    existing_flights = {f.flight_id: f for f in FlightPath.query.all()}

    for state in states['states']:
        flight_id = state[0]
        lon = state[5]
        lat = state[6]
        alt = state[7] if state[7] is not None else -1
        vel = state[9] if state[9] is not None else -1
        if lat is None or lon is None:
            continue

        new_point = [lat, lon, timestamp, alt, vel]
        flight = existing_flights.get(flight_id)

        if flight:
            current_points = flight.points_list
            current_coords = [[p[0], p[1]] for p in current_points]
            if [lat, lon] not in current_coords:
                current_points.append(new_point)
                flight.points = json.dumps(current_points)  # Encode as JSON
                attributes.flag_modified(flight, "points")
                flight.last_updated = timestamp
                flight.update_stats()
                analyze_flight(flight)
                flight_updates.append({
                    'flight_id': flight_id,
                    'points': flight.points_list,
                    'classification': flight.classification,
                    'classification_source': flight.classification_source,
                    'avg_altitude': flight.avg_altitude,
                    'avg_velocity': flight.avg_velocity,
                    'duration': flight.duration
                })
        else:
            new_flight = FlightPath(flight_id=flight_id, points=[new_point], last_updated=timestamp)
            new_flight.update_stats()
            analyze_flight(new_flight)
            flight_updates.append({
                'flight_id': flight_id,
                'points': new_flight.points_list,
                'classification': new_flight.classification,
                'classification_source': new_flight.classification_source,
                'avg_altitude': new_flight.avg_altitude,
                'avg_velocity': new_flight.avg_velocity,
                'duration': new_flight.duration
            })
            new_flights.append(new_flight)

    if new_flights:
        db.session.bulk_save_objects(new_flights)
        logger.info(f"Added {len(new_flights)} new flights")
    if flight_updates:
        db.session.commit()
        logger.info(f"Updated {len(flight_updates)} flights")

    if flight_updates:
        socketio.emit('flight_batch_update', {'flights': flight_updates})
        logger.debug(f"Emitted batch update for {len(flight_updates)} flights")

def monitor_area(app, socketio, area, frequency):
    while True:
        with app.app_context():
            current_area = MonitoredArea.query.get(area.id)
            if not current_area or not current_area.is_monitoring:
                logger.info(f"Area ID {area.id} no longer exists or stopped, stopping thread")
                break
            states = fetch_flight_data(area)
            if states:
                process_states(states, socketio)
            cleanup_old_flights()
        time.sleep(frequency)

def start_monitoring_thread(app, socketio, area):
    freq = {'30s': 30, '1m': 60, '5m': 300}[area.frequency]
    thread = threading.Thread(target=monitor_area, args=(app, socketio, area, freq))
    thread.daemon = True
    thread.start()

def start_monitoring(app, socketio):
    with app.app_context():
        areas = MonitoredArea.query.all()
        for area in areas:
            if area.is_monitoring:
                start_monitoring_thread(app, socketio, area)

def init_indexes():
    db.session.execute(text("CREATE INDEX IF NOT EXISTS idx_flight_id ON flight_path (flight_id)"))
    db.session.execute(text("CREATE INDEX IF NOT EXISTS idx_last_updated ON flight_path (last_updated)"))
    db.session.commit()
    logger.info("Database indexes created")
flight_tracker/models.py
python
from flask_sqlalchemy import SQLAlchemy
import json
from flight_tracker.utils import logger

db = SQLAlchemy()

def init_db(app):
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////data/flights.db'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    db.init_app(app)
    with app.app_context():
        db.create_all()

class MonitoredArea(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    lamin = db.Column(db.Float, nullable=False)
    lamax = db.Column(db.Float, nullable=False)
    lomin = db.Column(db.Float, nullable=False)
    lomax = db.Column(db.Float, nullable=False)
    frequency = db.Column(db.String(10), nullable=False)
    is_monitoring = db.Column(db.Boolean, default=False)

class FlightPath(db.Model):
    flight_id = db.Column(db.String(20), primary_key=True)
    points = db.Column(db.Text, nullable=True)  # JSON-encoded list of [lat, lon, timestamp, alt, vel]
    last_updated = db.Column(db.Integer, nullable=False)
    classification = db.Column(db.String(20))
    classification_source = db.Column(db.String(20))
    auto_classified = db.Column(db.Boolean, default=True)
    avg_altitude = db.Column(db.Float, default=-1)
    avg_velocity = db.Column(db.Float, default=-1)
    duration = db.Column(db.Integer, default=0)

    def __init__(self, flight_id, points=None, last_updated=0):
        self.flight_id = flight_id
        self.points = json.dumps(points) if points else None
        self.last_updated = last_updated
        self.update_stats()

    def update_stats(self):
        if self.points:
            points = json.loads(self.points) if isinstance(self.points, str) else self.points
            normalized_points = []
            for p in points:
                if not isinstance(p, list):
                    logger.warning(f"Invalid point format for {self.flight_id}: {p}")
                    continue
                while len(p) < 5:
                    p.append(-1)
                normalized_points.append(p)
            self.points = json.dumps(normalized_points)
            altitudes = [p[3] for p in normalized_points if p[3] != -1]
            velocities = [p[4] for p in normalized_points if p[4] != -1]
            timestamps = [p[2] for p in normalized_points]
            self.avg_altitude = sum(altitudes) / len(altitudes) if altitudes else -1
            self.avg_velocity = sum(velocities) / len(velocities) if velocities else -1
            self.duration = max(timestamps) - min(timestamps) if len(timestamps) > 1 else 0

    @property
    def points_list(self):
        if self.points:
            points = json.loads(self.points) if isinstance(self.points, str) else self.points
            normalized_points = []
            for p in points:
                if not isinstance(p, list):
                    logger.warning(f"Invalid point format on read for {self.flight_id}: {p}")
                    continue
                while len(p) < 5:
                    p.append(-1)
                normalized_points.append(p)
            return normalized_points
        return []
flight_tracker/analysis.py
python
from sklearn.ensemble import RandomForestClassifier
from sklearn.utils.validation import check_is_fitted
import numpy as np
from flight_tracker.utils import logger
from flight_tracker.ml_model import load_model, save_model

def analyze_flight(flight):
    if not hasattr(analyze_flight, 'model'):
        analyze_flight.model = load_model() or RandomForestClassifier(n_estimators=100, random_state=42)

    points = flight.points_list or []
    if not points or len(points) < 2:
        flight.classification = None
        flight.classification_source = None
        flight.auto_classified = False
        return

    valid_points = [p for p in points if isinstance(p, list) and len(p) >= 3]
    if len(valid_points) < 2:
        logger.warning(f"Invalid points data for flight {flight.flight_id}: {points}")
        flight.classification = None
        flight.classification_source = None
        flight.auto_classified = False
        return

    altitudes = [p[3] if len(p) > 3 and p[3] != -1 else -1 for p in valid_points]
    velocities = [p[4] if len(p) > 4 and p[4] != -1 else -1 for p in valid_points]
    lat_lons = [(p[0], p[1]) for p in valid_points]
    turns = 0
    if len(lat_lons) > 2:
        for i in range(len(lat_lons) - 2):
            v1 = (lat_lons[i+1][0] - lat_lons[i][0], lat_lons[i+1][1] - lat_lons[i][1])
            v2 = (lat_lons[i+2][0] - lat_lons[i+1][0], lat_lons[i+2][1] - lat_lons[i+1][1])
            dot = v1[0] * v2[0] + v1[1] * v2[1]
            mag1 = (v1[0]**2 + v1[1]**2)**0.5
            mag2 = (v2[0]**2 + v2[1]**2)**0.5
            if mag1 * mag2 > 0:
                cos_angle = dot / (mag1 * mag2)
                if cos_angle < 0.7:  # ~45° turn
                    turns += 1

    features = [
        np.mean(altitudes) if any(a != -1 for a in altitudes) else -1,
        np.mean(velocities) if any(v != -1 for v in velocities) else -1,
        turns / len(valid_points) if valid_points else 0
    ]

    if features[0] > 5000 and features[1] > 100:
        flight.classification = 'commercial'
        flight.classification_source = 'rule'
        flight.auto_classified = False
    elif features[0] < 1000 and features[2] > 0.1:
        flight.classification = 'survey'
        flight.classification_source = 'rule'
        flight.auto_classified = False
    elif features[0] < 2000 and features[1] < 50:
        flight.classification = 'cloud seeding'
        flight.classification_source = 'rule'
        flight.auto_classified = False
    else:
        try:
            check_is_fitted(analyze_flight.model)
            prediction = analyze_flight.model.predict([features])[0]
            flight.classification = prediction
            flight.classification_source = 'ml'
            flight.auto_classified = True
            logger.info(f"Classified flight {flight.flight_id} as {prediction} (ML)")
        except Exception as e:
            logger.info(f"ML model not fitted or failed for {flight.flight_id}: {e}. Using rule-based fallback.")
            flight.classification = None
            flight.classification_source = None
            flight.auto_classified = False
flight_tracker/ml_model.py
python
import pickle
import os
from sklearn.ensemble import RandomForestClassifier
from flight_tracker.utils import logger
from flight_tracker.models import db, FlightPath

MODEL_PATH = '/data/flight_model.pkl'

def load_model():
    """Load the saved model from disk."""
    if os.path.exists(MODEL_PATH):
        try:
            with open(MODEL_PATH, 'rb') as f:
                model = pickle.load(f)
                logger.info("Model loaded from disk")
                return model
        except Exception as e:
            logger.error(f"Failed to load model: {e}")
            return None
    logger.info("No saved model found, returning None")
    return None

def save_model(model):
    """Save the model to disk."""
    try:
        with open(MODEL_PATH, 'wb') as f:
            pickle.dump(model, f)
        logger.info("Model saved to disk")
    except Exception as e:
        logger.error(f"Failed to save model: {e}")

def train_model():
    """Train the model using manual classifications from the database."""
    flights = FlightPath.query.filter_by(auto_classified=False).filter(FlightPath.classification.isnot(None)).all()
    if len(flights) < 10:
        logger.warning(f"Insufficient manually classified flights to train model: {len(flights)} found")
        return False

    X = []
    y = []
    for flight in flights:
        points = flight.points_list
        if len(points) < 2:
            continue
        altitudes = [p[3] for p in points if p[3] != -1]
        velocities = [p[4] for p in points if p[4] != -1]
        lat_lons = [(p[0], p[1]) for p in points]
        turns = 0
        if len(lat_lons) > 2:
            for i in range(len(lat_lons) - 2):
                v1 = (lat_lons[i+1][0] - lat_lons[i][0], lat_lons[i+1][1] - lat_lons[i][1])
                v2 = (lat_lons[i+2][0] - lat_lons[i+1][0], lat_lons[i+2][1] - lat_lons[i+1][1])
                dot = v1[0] * v2[0] + v1[1] * v2[1]
                mag1 = (v1[0]**2 + v1[1]**2)**0.5
                mag2 = (v2[0]**2 + v2[1]**2)**0.5
                if mag1 * mag2 > 0:
                    cos_angle = dot / (mag1 * mag2)
                    if cos_angle < 0.7:
                        turns += 1
        features = [
            sum(altitudes) / len(altitudes) if altitudes else -1,
            sum(velocities) / len(velocities) if velocities else -1,
            turns / len(points) if points else 0
        ]
        X.append(features)
        y.append(flight.classification)

    if len(X) < 2 or len(set(y)) < 2:
        logger.warning(f"Insufficient data variety to train model: {len(X)} samples, {len(set(y))} unique classes")
        return False

    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X, y)
    save_model(model)
    return True
flight_tracker/routes.py
python
from flask import render_template, request, jsonify
from flight_tracker.utils import logger
from flight_tracker.models import db, MonitoredArea, FlightPath
from flight_tracker.monitoring import start_monitoring_thread
from flight_tracker.ml_model import train_model

def register_routes(app, socketio):
    @app.route('/')
    def index():
        return render_template('index.html')

    @app.route('/start_monitoring', methods=['POST'])
    def start_monitoring():
        data = request.get_json()
        lamin = data.get('lamin')
        lamax = data.get('lamax')
        lomin = data.get('lomin')
        lomax = data.get('lomax')
        frequency = data.get('frequency')

        if not all([lamin, lamax, lomin, lomax, frequency]):
            return jsonify({'error': 'Missing parameters'}), 400

        area = MonitoredArea(lamin=lamin, lamax=lamax, lomin=lomin, lomax=lomax, frequency=frequency, is_monitoring=True)
        db.session.add(area)
        db.session.commit()
        start_monitoring_thread(app, socketio, area)
        logger.info(f"Started monitoring for area ID {area.id}")
        return jsonify({'message': 'Monitoring started', 'area_id': area.id}), 200

    @app.route('/stop_monitoring', methods=['POST'])
    def stop_monitoring():
        data = request.get_json()
        area_id = data.get('area_id')
        if not area_id:
            logger.error("No area_id provided in stop_monitoring request")
            return jsonify({'error': 'Missing area_id'}), 400

        area = MonitoredArea.query.get(area_id)
        if area:
            area.is_monitoring = False
            db.session.commit()
            logger.info(f"Stopped monitoring for area ID {area_id}")
            return jsonify({'message': 'Monitoring stopped', 'area_id': area_id}), 200
        logger.warning(f"Area ID {area_id} not found for stop_monitoring")
        return jsonify({'error': 'Area not found'}), 404

    @app.route('/areas', methods=['GET'])
    def get_areas():
        areas = MonitoredArea.query.all()
        area_data = [
            {
                'id': area.id,
                'lamin': area.lamin,
                'lamax': area.lamax,
                'lomin': area.lomin,
                'lomax': area.lomax,
                'frequency': area.frequency,
                'is_monitoring': area.is_monitoring
            }
            for area in areas
        ]
        return jsonify(area_data)

    @app.route('/flight_paths', methods=['GET'])
    def get_flight_paths():
        flights = FlightPath.query.all()
        flight_data = [
            {
                'flight_id': flight.flight_id,
                'points': flight.points_list,
                'classification': flight.classification,
                'classification_source': flight.classification_source,
                'avg_altitude': flight.avg_altitude,
                'avg_velocity': flight.avg_velocity,
                'duration': flight.duration
            }
            for flight in flights
        ]
        return jsonify(flight_data)

    @app.route('/update_classification', methods=['POST'])
    def update_classification():
        data = request.get_json()
        flight_id = data.get('flight_id')
        classification = data.get('classification')
        
        if not flight_id or not classification:
            return jsonify({'error': 'Missing flight_id or classification'}), 400

        flight = FlightPath.query.filter_by(flight_id=flight_id).first()
        if flight:
            flight.classification = classification
            flight.auto_classified = False
            flight.classification_source = 'manual'
            db.session.commit()
            socketio.emit('flight_update', {
                'flight_id': flight.flight_id,
                'points': flight.points_list,
                'classification': flight.classification,
                'classification_source': flight.classification_source,
                'avg_altitude': flight.avg_altitude,
                'avg_velocity': flight.avg_velocity,
                'duration': flight.duration
            })
            return jsonify({'message': f'Classification updated for {flight_id}'}), 200
        return jsonify({'error': 'Flight not found'}), 404

    @app.route('/retrain_model', methods=['POST'])
    def retrain_model_endpoint():
        success = train_model()
        if success:
            return jsonify({'message': 'Model retrained successfully'}), 200
        return jsonify({'error': 'Failed to retrain model (insufficient data or error)'}), 400

    @app.route('/delete_area', methods=['POST'])
    def delete_area():
        data = request.get_json()
        area_id = data.get('area_id')
        if not area_id:
            logger.error("No area_id provided in delete_area request")
            return jsonify({'error': 'Missing area_id'}), 400

        area = MonitoredArea.query.get(area_id)
        if area:
            db.session.delete(area)
            db.session.commit()
            logger.info(f"Deleted area ID {area_id}")
            return jsonify({'message': 'Area deleted', 'area_id': area_id}), 200
        logger.warning(f"Area ID {area_id} not found for deletion")
        return jsonify({'error': 'Area not found'}), 404
flight_tracker/utils.py
python
import logging
from logging.handlers import RotatingFileHandler

logger = logging.getLogger('flight_tracker.utils')
logger.setLevel(logging.INFO)

def setup_logging(socketio):
    handler = RotatingFileHandler('/data/flight_tracker.log', maxBytes=10000, backupCount=1)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.handlers = []  # Clear existing handlers
    logger.addHandler(handler)

    original_info = logger.info
    def socketio_info(msg, *args, **kwargs):
        original_info(msg, *args, **kwargs)
        socketio.emit('log', {'message': msg})
    logger.info = socketio_info

def appendLog(message):
    logger.info(message)
flight_tracker/templates/index.html
html
<!DOCTYPE html>
<html>
<head>
    <title>Flight Tracker Dashboard</title>
    <link rel="stylesheet" href="/static/style.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
</head>
<body>
    <div class="dashboard">
        <header class="top-bar">
            <h1>Flight Tracker</h1>
            <div class="stats">
                <span>Tracked Flights: <span id="flight-count">0</span></span>
                <span>Active Areas: <span id="area-count">0</span></span>
            </div>
        </header>
        <div class="main-content">
            <div class="map-container">
                <div id="map"></div>
                <div class="legend">
                    <div><span style="color: #808080;">⋯</span> Disabled Area</div>
                    <div><span style="color: #006400;">⋯</span> Monitored Area</div>
                    <div><span style="color: #00ff00;">■</span> Commercial</div>
                    <div><span style="color: #ff0000;">■</span> Survey</div>
                    <div><span style="color: #FFA500;">■</span> Agriculture</div>
                    <div><span style="color: #0000FF;">■</span> Cloud Seeding</div>
                </div>
            </div>
            <aside class="sidebar">
                <div class="controls">
                    <h2>Controls</h2>
                    <select id="frequency">
                        <option value="30s">30s</option>
                        <option value="1m">1m</option>
                        <option value="5m">5m</option>
                    </select>
                    <button id="monitor-btn" onclick="toggleMonitoring()">Start Monitoring</button>
                    <button id="delete-btn" onclick="deleteArea()" disabled>Delete Area</button>
                    <button id="retrain-btn" onclick="retrainModel()" disabled>Retrain Model</button>
                </div>
                <div class="flight-list">
                    <h2>Active Flights</h2>
                    <input type="text" id="flight-filter" placeholder="Filter flights..." onkeyup="filterFlights()">
                    <select id="class-filter" onchange="filterFlights()">
                        <option value="">All Classifications</option>
                        <option value="commercial">Commercial</option>
                        <option value="survey">Survey</option>
                        <option value="agriculture">Agriculture</option>
                        <option value="cloud seeding">Cloud Seeding</option>
                    </select>
                    <div id="flight-list-content"></div>
                </div>
                <div class="flight-info" id="flight-info">
                    <h2>Flight Details</h2>
                    <div id="flight-details">Select a flight to see details</div>
                </div>
            </aside>
        </div>
        <footer class="log-container">
            <h2>Logs</h2>
            <pre id="log"></pre>
        </footer>
    </div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.js"></script>
    <script src="/static/js/map.js"></script>
    <script src="/static/js/controls.js"></script>
    <script src="/static/js/socket.js"></script>
    <script src="/static/js/utils.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            setupSocketEvents();
            updateFlightPaths();
            setInterval(updateFlightPaths, 10000);
        });
    </script>
</body>
</html>
flight_tracker/static/js/map.js
javascript
let areas = [];
let drawing = false;
let startLatLng = null;
let currentRectangle = null;
let selectedArea = null;
const flightLines = {};
const flightLayer = L.layerGroup();
let hasZoomed = false;
let selectedFlightId = null;

const map = L.map('map').setView([56.0, 11.0], 6);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
}).addTo(map);
flightLayer.addTo(map);

const airplaneSvg = `
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M20.5 3.5L3.5 12L9.5 14.5L15.5 9.5L10.5 15.5L13 20.5L20.5 3.5Z" fill="#333" stroke="#333" stroke-width="2"/>
    </svg>
`;

function debounce(func, wait) {
    let timeout;
    return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

function initMap() {
    console.log('Initializing map and flightLayer');
    fetch('/areas')
        .then(response => response.json())
        .then(data => {
            data.forEach(area => {
                const bounds = L.latLngBounds([area.lamin, area.lomin], [area.lamax, area.lomax]);
                addArea(bounds, area.is_monitoring, area.id, area.frequency);
            });
        })
        .catch(error => console.error('Error loading areas:', error));

    map.on('mousedown', (e) => {
        if (e.originalEvent.shiftKey) {
            drawing = true;
            startLatLng = e.latlng;
            currentRectangle = L.rectangle([[startLatLng.lat, startLatLng.lng], [startLatLng.lat, startLatLng.lng]], {
                color: '#808080',
                weight: 2,
                dashArray: '5, 5',
                fillOpacity: 0
            }).addTo(map);
        }
    });

    map.on('mousemove', (e) => {
        if (drawing && currentRectangle) {
            const bounds = L.latLngBounds(startLatLng, e.latlng);
            currentRectangle.setBounds(bounds);
        }
    });

    map.on('mouseup', (e) => {
        if (drawing && currentRectangle) {
            drawing = false;
            const bounds = currentRectangle.getBounds();
            const frequency = document.getElementById('frequency').value;
            persistArea(bounds, false, frequency);
            map.removeLayer(currentRectangle);
            currentRectangle = null;
        }
    });

    map.on('click', (e) => {
        const clickedOnArea = areas.some(area => area.rectangle.getBounds().contains(e.latlng));
        if (!clickedOnArea && !e.originalEvent.shiftKey) {
            console.log('Clicked outside, deselecting area');
            deselectArea();
            deselectFlight();
        }
    });
}

function persistArea(bounds, isMonitoring, frequency) {
    fetch('/start_monitoring', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            lamin: bounds.getSouth(),
            lamax: bounds.getNorth(),
            lomin: bounds.getWest(),
            lomax: bounds.getEast(),
            frequency: frequency
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            console.error(data.error);
        } else {
            addArea(bounds, isMonitoring, data.area_id, frequency);
            appendLog(`Area created with ID ${data.area_id}`);
        }
    });
}

function addArea(bounds, isMonitoring, id, frequency) {
    const style = isMonitoring ? 
        { color: '#006400', weight: 2, dashArray: '5, 5', fillOpacity: 0 } : 
        { color: '#808080', weight: 2, dashArray: '5, 5', fillOpacity: 0 };
    const rectangle = L.rectangle(bounds, style).addTo(map);
    const area = { rectangle, bounds, isMonitoring, id, frequency };
    rectangle.on('click', (e) => {
        L.DomEvent.stopPropagation(e);
        console.log(`Area clicked, selecting: ${JSON.stringify(bounds)}`);
        selectArea(area);
    });
    areas.push(area);
    updateStats();
    updateMonitorButton();
}

function selectArea(area) {
    if (selectedArea && selectedArea !== area) {
        console.log(`Deselecting previous area: ${JSON.stringify(selectedArea.bounds)}`);
        updateAreaStyle(selectedArea);
    }
    selectedArea = area;
    console.log(`Selecting new area: ${JSON.stringify(area.bounds)}`);
    updateAreaStyle(area);
    updateMonitorButton();
    document.getElementById('delete-btn').disabled = false;
}

function deselectArea() {
    if (selectedArea) {
        console.log(`Deselecting area: ${JSON.stringify(selectedArea.bounds)}`);
        updateAreaStyle(selectedArea);
        selectedArea = null;
        updateMonitorButton();
        document.getElementById('delete-btn').disabled = true;
    }
}

function updateAreaStyle(area) {
    const fillOpacity = (area === selectedArea) ? 0.05 : 0;
    const fillColor = '#00ff00';
    console.log(`Updating style for area: ${JSON.stringify(area.bounds)}, selected: ${area === selectedArea}, fillOpacity: ${fillOpacity}`);
    area.rectangle.setStyle({
        color: area.is_monitoring ? '#006400' : '#808080',
        fillOpacity: fillOpacity,
        fillColor: fillColor
    });
}

function calculateBearing(lat1, lon1, lat2, lon2) {
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const y = Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180);
    const x = Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) - 
              Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon);
    const bearing = Math.atan2(y, x);
    return (bearing * 180 / Math.PI + 360) % 360;
}

function renderFlightPath(flight) {
    console.log('Rendering flight:', flight);
    const coords = flight.points.map(p => [p[0], p[1]]);
    console.log('Coordinates:', coords);
    
    const flightData = flightLines[flight.flight_id] || {};
    flightLines[flight.flight_id] = flightData;
    flightData.points = flight.points;  // Store full points for stats
    flightData.classification = flight.classification;
    flightData.classification_source = flight.classification_source;
    flightData.avg_altitude = flight.avg_altitude;
    flightData.avg_velocity = flight.avg_velocity;
    flightData.duration = flight.duration;

    const color = flight.classification === 'commercial' ? '#00ff00' :
                 flight.classification === 'survey' ? '#ff0000' :
                 flight.classification === 'agriculture' ? '#FFA500' :
                 flight.classification === 'cloud seeding' ? '#0000FF' : '#808080';
    const isSelected = flight.flight_id === selectedFlightId;
    const opacity = selectedFlightId ? (isSelected ? 1 : 0.1) : 0.8;
    let rotation = 0;

    if (coords.length >= 1) {  // Render marker even with 1 point
        const lastPoint = flight.points[flight.points.length - 1];
        const altitude = lastPoint[3] === -1 ? 'N/A' : `${lastPoint[3]} m`;
        const velocity = lastPoint[4] === -1 ? 'N/A' : `${lastPoint[4]} m/s`;
        const avgAltitude = flight.avg_altitude === -1 ? 'N/A' : `${Math.round(flight.avg_altitude)} m`;
        const avgVelocity = flight.avg_velocity === -1 ? 'N/A' : `${Math.round(flight.avg_velocity)} m/s`;
        const duration = flight.duration === 0 ? 'N/A' : `${Math.round(flight.duration / 60)} min`;

        if (coords.length > 1) {
            if (flightData.line) {
                flightData.line.setLatLngs(coords);
            } else {
                flightData.line = L.polyline(coords, { color: color, weight: 4, opacity: opacity });
                flightData.line.addTo(flightLayer);
            }
            flightData.line.bindPopup(`Flight: ${flight.flight_id}<br>Class: ${flight.classification || 'N/A'} (${flight.classification_source || 'N/A'})<br>Altitude: ${altitude}<br>Velocity: ${velocity}<br>Avg Altitude: ${avgAltitude}<br>Avg Velocity: ${avgVelocity}<br>Duration: ${duration}`);
            flightData.line.setStyle({ opacity: opacity });
            const lastPoints = coords.slice(-3);
            if (lastPoints.length >= 2) {
                const [lat2, lon2] = lastPoints[lastPoints.length - 1];
                const [lat1, lon1] = lastPoints[lastPoints.length - 2];
                rotation = calculateBearing(lat1, lon1, lat2, lon2) - 45;
                console.log('Calculated rotation:', rotation, 'from', [lat1, lon1], 'to', [lat2, lon2]);
            } else {
                rotation = flightData.lastRotation || 0;
            }
            console.log('Updated/Added polyline for:', flight.flight_id);
        } else if (flightData.line) {
            flightLayer.removeLayer(flightData.line);
            delete flightData.line;
        }

        const airplaneIcon = L.divIcon({
            html: `<div style="transform: rotate(${rotation}deg);">${airplaneSvg}</div>`,
            className: 'airplane-icon',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });

        if (flightData.marker) {
            flightData.marker.setLatLng(coords[coords.length - 1]);
            flightData.marker.setIcon(airplaneIcon);
            flightData.marker.setOpacity(opacity);
        } else {
            flightData.marker = L.marker(coords[coords.length - 1], { icon: airplaneIcon })
                .bindPopup(`Flight: ${flight.flight_id}<br>Class: ${flight.classification || 'N/A'} (${flight.classification_source || 'N/A'})<br>Altitude: ${altitude}<br>Velocity: ${velocity}<br>Avg Altitude: ${avgAltitude}<br>Avg Velocity: ${avgVelocity}<br>Duration: ${duration}`)
                .addTo(flightLayer);
            flightData.marker.setOpacity(opacity);
        }
        console.log('Updated/Added marker for:', flight.flight_id);
    }
    console.log('Current flightLines:', Object.keys(flightLines));
}

const debouncedRenderFlightPath = debounce(renderFlightPath, 100);

function selectFlight(flightId) {
    selectedFlightId = flightId;
    Object.keys(flightLines).forEach(id => {
        const flightData = flightLines[id];
        const isSelected = id === flightId;
        const opacity = isSelected ? 1 : 0.1;
        if (flightData.line) {
            flightData.line.setStyle({ opacity: opacity });
        }
        if (flightData.marker) {
            flightData.marker.setOpacity(opacity);
        }
    });
    if (flightLines[flightId]) {
        if (flightLines[flightId].line) {
            map.fitBounds(flightLines[flightId].line.getBounds());
        } else if (flightLines[flightId].marker) {
            map.setView(flightLines[flightId].marker.getLatLng(), 10);
        }
        const flight = flightLines[flightId];
        const lastPoint = flight.points[flight.points.length - 1];
        const altitude = lastPoint[3] === -1 ? 'N/A' : `${lastPoint[3]} m`;
        const velocity = lastPoint[4] === -1 ? 'N/A' : `${lastPoint[4]} m/s`;
        const avgAltitude = flight.avg_altitude === -1 ? 'N/A' : `${Math.round(flight.avg_altitude)} m`;
        const avgVelocity = flight.avg_velocity === -1 ? 'N/A' : `${Math.round(flight.avg_velocity)} m/s`;
        const duration = flight.duration === 0 ? 'N/A' : `${Math.round(flight.duration / 60)} min`;
        document.getElementById('flight-details').innerHTML = `
            <p><strong>Flight ID:</strong> ${flightId}</p>
            <p><strong>Classification:</strong> ${flight.classification || 'N/A'}</p>
            <p><strong>Altitude:</strong> ${altitude}</p>
            <p><strong>Velocity:</strong> ${velocity}</p>
            <p><strong>Avg Altitude:</strong> ${avgAltitude}</p>
            <p><strong>Avg Velocity:</strong> ${avgVelocity}</p>
            <p><strong>Duration:</strong> ${duration}</p>
        `;
    } else {
        document.getElementById('flight-details').innerHTML = 'Select a flight to see details';
    }
    updateFlightList();
}

function deselectFlight() {
    selectedFlightId = null;
    Object.keys(flightLines).forEach(id => {
        const flightData = flightLines[id];
        const opacity = 0.8;
        if (flightData.line) {
            flightData.line.setStyle({ opacity: opacity });
        }
        if (flightData.marker) {
            flightData.marker.setOpacity(opacity);
        }
    });
    document.getElementById('flight-details').innerHTML = 'Select a flight to see details';
    updateFlightList();
}
flight_tracker/static/js/utils.js
javascript
let canRetrain = false;
let updateTimeout = null;

function appendLog(message) {
    const log = document.getElementById('log');
    log.innerText = message + '\n' + log.innerText;
    log.scrollTop = 0;
}

function debounceUpdateFlightPaths() {
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(updateFlightPaths, 500);
}

function updateFlightPaths() {
    fetch('/flight_paths')
        .then(response => response.json())
        .then(data => {
            console.log('Fetched flight paths:', data);
            const activeFlightIds = new Set(data.map(f => f.flight_id));
            Object.keys(flightLines).forEach(id => {
                if (!activeFlightIds.has(id)) {
                    if (flightLines[id].line) flightLayer.removeLayer(flightLines[id].line);
                    if (flightLines[id].marker) flightLayer.removeLayer(flightLines[id].marker);
                    delete flightLines[id];
                }
            });
            data.forEach(flight => debouncedRenderFlightPath(flight));
            updateFlightList();
            updateStats();
            fetch('/flight_paths').then(r => r.json()).then(data => {
                const classCounts = data.reduce((acc, f) => {
                    acc[f.classification] = (acc[f.classification] || 0) + 1;
                    return acc;
                }, {});
                canRetrain = Object.keys(classCounts).length > 1 && data.length >= 10;
                document.getElementById('retrain-btn').disabled = !canRetrain;
            });
        })
        .catch(error => console.error('Error fetching paths:', error));
}

function updateFlightList() {
    const list = document.getElementById('flight-list-content');
    list.innerHTML = '';
    console.log('Updating flight list with flightLines:', Object.keys(flightLines));
    Object.keys(flightLines).forEach(id => {
        const flight = flightLines[id];
        const popupContent = flight.line ? flight.line.getPopup()?.getContent() || '' : flight.marker.getPopup()?.getContent() || '';
        const currentClass = popupContent.match(/Class: (.*?)(?:\s\(|$)/)?.[1] || 'N/A';
        const source = popupContent.match(/\((.*?)\)/)?.[1] || 'N/A';
        const lastPoint = flight.points[flight.points.length - 1];
        const altitude = lastPoint[3] === -1 ? 'N/A' : `${lastPoint[3]} m`;
        const velocity = lastPoint[4] === -1 ? 'N/A' : `${lastPoint[4]} m/s`;
        const avgAltitude = flight.avg_altitude === -1 ? 'N/A' : `${Math.round(flight.avg_altitude)} m`;
        const avgVelocity = flight.avg_velocity === -1 ? 'N/A' : `${Math.round(flight.avg_velocity)} m/s`;
        const duration = flight.duration === 0 ? 'N/A' : `${Math.round(flight.duration / 60)} min`;
        const heading = flight.line ? (flight.line.getLatLngs().length > 1 ? flight.lastRotation || 'N/A' : 'N/A') : 'N/A';

        const div = document.createElement('div');
        if (id === selectedFlightId) {
            div.className = 'flight-item detailed';
            div.innerHTML = `
                <div class="flight-header">
                    <svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#e0e0e0" stroke-width="2">
                        <path d="M20.5 3.5L3.5 12L9.5 14.5L15.5 9.5L10.5 15.5L13 20.5L20.5 3.5Z"/>
                    </svg>
                    <span>${id}</span>
                </div>
                <div class="flight-data">
                    <div>
                        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#e0e0e0" stroke-width="2">
                            <path d="M12 2v20m10-10H2"/>
                        </svg>
                        <span>Alt: ${altitude}</span>
                    </div>
                    <div>
                        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#e0e0e0" stroke-width="2">
                            <path d="M22 11h-8l-2-9L2 12l10 10 2-9h8z"/>
                        </svg>
                        <span>Vel: ${velocity}</span>
                    </div>
                    <div>
                        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#e0e0e0" stroke-width="2">
                            <path d="M12 2v10l8 4-8-14zm0 20v-6"/>
                        </svg>
                        <span>Heading: ${heading === 'N/A' ? 'N/A' : `${Math.round(heading)}°`}</span>
                    </div>
                    <div>
                        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#e0e0e0" stroke-width="2">
                            <path d="M12 2v20m10-10H2"/>
                        </svg>
                        <span>Avg Alt: ${avgAltitude}</span>
                    </div>
                    <div>
                        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#e0e0e0" stroke-width="2">
                            <path d="M22 11h-8l-2-9L2 12l10 10 2-9h8z"/>
                        </svg>
                        <span>Avg Vel: ${avgVelocity}</span>
                    </div>
                    <div>
                        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#e0e0e0" stroke-width="2">
                            <path d="M12 2v6m0 10v6m-6-12h12"/>
                        </svg>
                        <span>Duration: ${duration}</span>
                    </div>
                </div>
                <select onchange="updateClassification('${id}', this.value)">
                    <option value="commercial" ${currentClass === 'commercial' ? 'selected' : ''}>Commercial</option>
                    <option value="survey" ${currentClass === 'survey' ? 'selected' : ''}>Survey</option>
                    <option value="agriculture" ${currentClass === 'agriculture' ? 'selected' : ''}>Agriculture</option>
                    <option value="cloud seeding" ${currentClass === 'cloud seeding' ? 'selected' : ''}>Cloud Seeding</option>
                </select>
                <span class="source">(${source})</span>
            `;
        } else {
            div.className = 'flight-item compact';
            div.innerHTML = `
                <svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#e0e0e0" stroke-width="2">
                    <path d="M20.5 3.5L3.5 12L9.5 14.5L15.5 9.5L10.5 15.5L13 20.5L20.5 3.5Z"/>
                </svg>
                <span>${id} - ${currentClass}</span>
            `;
        }
        div.dataset.classification = currentClass;
        div.style.backgroundColor = id === selectedFlightId ? '#3c3c3c' : '';
        div.onclick = () => {
            selectFlight(id);
        };
        list.appendChild(div);
    });
    filterFlights();
}

function updateStats() {
    document.getElementById('flight-count').innerText = Object.keys(flightLines).length;
    document.getElementById('area-count').innerText = areas.filter(a => a.is_monitoring).length;
}

function updateClassification(flightId, classification) {
    fetch('/update_classification', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ flight_id: flightId, classification: classification })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            console.error(data.error);
        } else {
            appendLog(data.message);
            debounceUpdateFlightPaths();
        }
    })
    .catch(error => console.error('Error:', error));
}

function filterFlights() {
    const textFilter = document.getElementById('flight-filter').value.toLowerCase();
    const classFilter = document.getElementById('class-filter').value;
    const list = document.getElementById('flight-list-content');
    Array.from(list.children).forEach(div => {
        const text = div.textContent.toLowerCase();
        const classification = div.dataset.classification || 'N/A';
        const matchesText = text.includes(textFilter);
        const matchesClass = !classFilter || classification === classFilter;
        div.style.display = matchesText && matchesClass ? '' : 'none';
    });
}
flight_tracker/static/js/socket.js
javascript
const socket = io();

function setupSocketEvents() {
    socket.on('log', (data) => {
        appendLog(data.message);
    });

    socket.on('flight_update', (flight) => {
        console.log('Received flight_update:', flight);
        debouncedRenderFlightPath(flight);
        updateFlightList();
        updateStats();
    });

    socket.on('flight_batch_update', (data) => {
        console.log('Received flight_batch_update:', data);
        let allCoords = [];
        data.flights.forEach(flight => {
            console.log('Processing flight:', flight);
            debouncedRenderFlightPath(flight);
            allCoords = allCoords.concat(flight.points.map(p => [p[0], p[1]]));
        });
        if (allCoords.length > 0 && !hasZoomed) {
            map.fitBounds(allCoords);
            hasZoomed = true;
        }
        updateFlightList();
        updateStats();
    });
}
flight_tracker/static/js/controls.js
javascript
function toggleMonitoring() {
    if (!selectedArea) {
        console.log('No area selected for monitoring');
        return;
    }

    const isMonitoring = selectedArea.isMonitoring;
    const endpoint = isMonitoring ? '/stop_monitoring' : '/start_monitoring';
    const data = isMonitoring ? { area_id: selectedArea.id } : {
        lamin: selectedArea.bounds.getSouth(),
        lamax: selectedArea.bounds.getNorth(),
        lomin: selectedArea.bounds.getWest(),
        lomax: selectedArea.bounds.getEast(),
        frequency: document.getElementById('frequency').value
    };

    fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            console.error(data.error);
            appendLog(`Error: ${data.error}`);
        } else {
            appendLog(data.message);
            selectedArea.isMonitoring = !isMonitoring;
            updateAreaStyle(selectedArea);
            updateMonitorButton();
            if (!isMonitoring) {
                areas = areas.filter(a => a.id !== selectedArea.id);
                areas.push(selectedArea);
            }
        }
    })
    .catch(error => console.error('Error toggling monitoring:', error));
}

function deleteArea() {
    if (!selectedArea) {
        console.log('No area selected to delete');
        return;
    }

    fetch('/delete_area', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ area_id: selectedArea.id })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            console.error(data.error);
            appendLog(`Error: ${data.error}`);
        } else {
            appendLog(data.message);
            map.removeLayer(selectedArea.rectangle);
            areas = areas.filter(a => a !== selectedArea);
            selectedArea = null;
            updateMonitorButton();
            document.getElementById('delete-btn').disabled = true;
        }
    })
    .catch(error => console.error('Error deleting area:', error));
}

function retrainModel() {
    fetch('/retrain_model', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            console.error(data.error);
            appendLog(`Error: ${data.error}`);
        } else {
            appendLog(data.message);
        }
    })
    .catch(error => console.error('Error retraining model:', error));
}

function updateMonitorButton() {
    const btn = document.getElementById('monitor-btn');
    if (selectedArea) {
        btn.textContent = selectedArea.isMonitoring ? 'Stop Monitoring' : 'Start Monitoring';
        btn.disabled = false;
    } else {
        btn.textContent = 'Start Monitoring';
        btn.disabled = true;
    }
}
flight_tracker/static/style.css
css
body {
    background: #1e1e1e;
    color: #e0e0e0;
    font-family: 'Segoe UI', Arial, sans-serif;
    margin: 0;
    padding: 0;
}

.dashboard {
    display: flex;
    flex-direction: column;
    height: 100vh;
}

.top-bar {
    background: #2d2d2d;
    padding: 15px 20px;
    border-bottom: 1px solid #444;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    border-radius: 0 0 10px 10px;
}

.top-bar h1 {
    margin: 0;
    font-size: 24px;
    color: #1a73e8;
}

.stats span {
    margin-left: 20px;
    font-weight: 500;
    color: #b0b0b0;
}

.main-content {
    display: flex;
    flex: 1;
    padding: 20px;
    gap: 20px;
    overflow: hidden;
}

.map-container {
    flex: 2;
    background: #252525;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    position: relative;
    overflow: hidden;
}

#map {
    height: 100%;
    width: 100%;
    border-radius: 10px;
}

.sidebar {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 20px;
    max-height: 100%;
    overflow: hidden;
}

.controls {
    background: #2d2d2d;
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.flight-list {
    background: #2d2d2d;
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
    flex: 1;
    overflow: hidden;
}

.flight-info {
    background: #2d2d2d;
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.controls h2, .flight-list h2, .flight-info h2 {
    margin: 0 0 10px;
    font-size: 18px;
    color: #b0b0b0;
}

select, button, input[type="text"] {
    padding: 8px 12px;
    margin: 5px 0;
    border: 1px solid #555;
    border-radius: 5px;
    background: #3c3c3c;
    color: #e0e0e0;
    cursor: pointer;
}

button {
    background: #1a73e8;
    color: #fff;
    border: none;
}

button:disabled {
    background: #555;
    cursor: not-allowed;
}

button:hover:not(:disabled) {
    background: #1557b0;
}

.flight-list-content {
    overflow-y: auto;
    flex: 1;
    min-height: 0;
}

.flight-item {
    padding: 5px 0;
    cursor: pointer;
    color: #e0e0e0;
}

.flight-item.compact {
    display: flex;
    align-items: center;
    padding: 8px;
}

.flight-item.compact:hover {
    background-color: #444;
}

.flight-item.detailed {
    padding: 10px;
    border: 1px solid #555;
    border-radius: 5px;
    margin-bottom: 5px;
}

.flight-item.detailed:hover {
    background-color: #444;
}

.flight-item.detailed[style*="background-color"] {
    background-color: #3c3c3c !important;
    color: #fff;
}

.flight-header {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
}

.flight-data {
    display: flex;
    flex-direction: column;
    gap: 5px;
    margin-left: 20px;
}

.flight-data div {
    display: flex;
    align-items: center;
}

.icon {
    margin-right: 5px;
}

.source {
    font-size: 12px;
    color: #b0b0b0;
}

.log-container {
    background: #2d2d2d;
    padding: 15px;
    border-top: 1px solid #444;
    border-radius: 10px 10px 0 0;
    box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.3);
}

.log-container h2 {
    margin: 0 0 10px;
    font-size: 18px;
    color: #b0b0b0;
}

#log {
    max-height: 150px;
    overflow-y: auto;
    font-family: 'Courier New', monospace;
    background: #333;
    color: #e0e0e0;
    padding: 10px;
    border-radius: 5px;
}

.legend {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(45, 45, 45, 0.9);
    padding: 5px 10px;
    border-radius: 5px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    color: #e0e0e0;
}

.legend div {
    margin: 3px 0;
    font-size: 12px;
}

.flight-info p {
    margin: 5px 0;
}
Dockerfile
dockerfile
FROM python:3.12-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 5000 5678

CMD ["python", "-m", "debugpy", "--listen", "0.0.0.0:5678", "flight_tracker"]
requirements.txt
flask
flask-socketio
requests
sqlalchemy
scikit-learn
numpy
debugpy
